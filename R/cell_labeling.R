#' @title Calculate normalized expression of a gene set
#' 
#' @description Calculate normalized expression for a set of genes in each cell
#'   from a \code{SingleCellExperiment}, using random sets of similarly
#'   expressed genes as background to account for cell quality and
#'   sequencing depth.
#'
#' @author Michael Stadler
#'
#' @param sce \code{SingleCellExperiment} object.
#' @param genes \code{character} vector with the genes in the set. Must be a
#'   subset of \code{rownames(sce)}.
#' @param expr_values Integer scalar or string indicating which assay of
#'   \code{sce} contains the expression values.
#' @param R Integer scalar giving the number of random gene sets to sample
#'   for normalization.
#' @param BPPARAM An optional \code{\link[BiocParallel]{BiocParallelParam}}
#'   instance determining the parallel back-end to be used during evaluation.
#' 
#' @return A \code{numeric} vector with normalized gene set scores for each
#'   cell in \code{sce}.
#' 
#' @importFrom BiocParallel SerialParam bplapply
#' @importFrom SummarizedExperiment assay assayNames
#' @importFrom matrixStats rowMeans2 rowSds
#' 
#' @export
normGenesetExpression <- function(sce,
                                  genes,
                                  expr_values = "logcounts",
                                  R = 200,
                                  BPPARAM = SerialParam()) {
    # pre-flight checks
    stopifnot(exprs = {
        is(sce, "SingleCellExperiment")
        is.character(genes)
        length(genes) > 1L
        all(genes %in% rownames(sce))
        is.numeric(R)
        length(R) == 1L
        R > 0
        inherits(BPPARAM, "BiocParallelParam")
    })
    if (is.numeric(expr_values) && length(expr_values) == 1L)
        expr_values <- assayNames(sce)[expr_values]
    stopifnot(exprs = {
        is.character(expr_values)
        length(expr_values) == 1L
        expr_values %in% assayNames(sce)
    })
    
    # calculate average expression of selected genes
    expr <- assay(sce, expr_values)
    i <- match(genes[genes %in% rownames(expr)], rownames(expr))
    avgExpr <- rowMeans(expr)
    val.obs <- colSums(expr[i, , drop = FALSE])
    
    # calculate expression in random gene sets
    val.rand <- do.call(cbind, bplapply(seq_len(R), function(r) {
        irand <- sampleControlElements(x = avgExpr, idxTarget = i, nbins = 100)
        colSums(expr[irand, , drop = FALSE])
    }, BPPARAM = BPPARAM))
    
    # normalize observed gene set expression
    # z values: (obs - exp) / sqrt(Var[exp])
    mus <- rowMeans2(val.rand)
    sds <- rowSds(val.rand)
    val.obs.norm <- (val.obs - mus) / sds
    names(val.obs.norm) <- colnames(sce)
    
    return(val.obs.norm)
}


#' @title Assign labels to cells using known marker genes
#' 
#' @description Given marker gene sets for cell types, identify cells with
#'   high expression of the marker genes (positive examples), then use these
#'   cells to create a reference transcriptome profile for each cell type and
#'   identify additional cells of each type using \code{SingleR}. These
#'   marker genes should specifically expressed a single cell type, e.g.
#'   CD3 which is expressed by all T cell subtypes would not be suitable
#'   for specific T cell subtypes.
#'
#' @author Michael Stadler
#'
#' @param sce \code{SingleCellExperiment} object.
#' @param markergenes Named \code{list} of \code{character} vectors with the
#'   marker genes for each cell types. The marker genes must be a subset of
#'   \code{rownames(sce)}.
#' @param fraction_topscoring \code{numeric} vector of length 1 or the same
#'   length as \code{markergenes} giving the fraction(s) of top scoring cells
#'   for each cell type to pick to create the reference transcriptome profile.
#' @param expr_values Integer scalar or string indicating which assay of
#'   \code{sce} contains the expression values.
#' @param normGenesetExpressionParams \code{list} with additional parameters
#'   for \code{\link{normGenesetExpression}}.
#' @param aggregateReferenceParams \code{list} with additional parameters
#'   for \code{\link[SingleR]{aggregateReference}}.
#' @param SingleRParams \code{list} with additional parameters for
#'   \code{\link[SingleR]{SingleR}}.
#' @param BPPARAM An optional \code{\link[BiocParallel]{BiocParallelParam}}
#'   instance determining the parallel back-end to be used during evaluation.
#' 
#' @return A \code{list} of three elements named \code{cells}, \code{refs} and \code{labels}.
#'   \code{cells} contains a \code{list} with the numerical indices of the top
#'   scoring cells for each cell type.
#'   \code{refs} contains the pseudo-bulk transcriptome profiles used as a 
#'   reference for label assignment, as returned by \code{\link[SingleR]{aggregateReference}}.
#'   \code{labels} contains a \code{\link[S4Vectors]{DataFrame}} with the
#'   annotation statistics for each cell (one cell per row), generated by
#'   \code{\link[SingleR]{SingleR}}.
#'   
#' @seealso \code{\link{normGenesetExpression}} used to calculate scores for
#'    marker gene sets; \code{\link[SingleR]{aggregateReference}} used to
#'    create reference profiles; \code{\link[SingleR]{SingleR}} used to assign
#'    labels to cells.
#'    
#' @importFrom SingleR SingleR aggregateReference
#' @importFrom BiocParallel SerialParam bplapply
#' 
#' @export
labelCells <- function(sce,
                       markergenes,
                       fraction_topscoring = 0.01,
                       expr_values = "logcounts",
                       normGenesetExpressionParams = list(R = 200),
                       aggregateReferenceParams = list(power = 0.5),
                       SingleRParams = list(),
                       BPPARAM = SerialParam()) {
    ## pre-flight checks
    stopifnot(exprs = {
        # sce
        is(sce, "SingleCellExperiment")
        # markergenes
        is(markergenes, "list")
        !is.null(names(markergenes))
        length(markergenes) > 1L
        all(lengths(markergenes) > 1L)
        all(vapply(markergenes, is.character, logical(1)))
        all(unlist(markergenes) %in% rownames(sce))
        # fraction_topscoring
        is.numeric(fraction_topscoring)
        length(fraction_topscoring) == 1L || length(fraction_topscoring) == length(markergenes)
        all(fraction_topscoring > 0) && all(fraction_topscoring < 1)
        # normGenesetExpressionParams
        is(normGenesetExpressionParams, "list")
        length(normGenesetExpressionParams) == 0 || !is.null(names(normGenesetExpressionParams))
        # aggregateReferenceParams
        is(aggregateReferenceParams, "list")
        length(aggregateReferenceParams) == 0 || !is.null(names(aggregateReferenceParams))
        # SingleRParams
        is(SingleRParams, "list")
        length(SingleRParams) == 0 || !is.null(names(SingleRParams))
    })
    if (is.numeric(expr_values) && length(expr_values) == 1L)
        expr_values <- assayNames(sce)[expr_values]
    stopifnot(exprs = {
        # expr_values
        is.character(expr_values)
        length(expr_values) == 1L
        expr_values %in% assayNames(sce)
    })
    
    ## calculate scores for marker gene sets
    todrop <- intersect(names(normGenesetExpressionParams),
                        c("sce", "genes", "expr_values", "BPPARAM"))
    if (length(todrop) > 0) {
        warning("ignoring the following user-provided elements in ",
                "'normGenesetExpressionParams': ",
                paste(todrop, collapse = ", "))
        normGenesetExpressionParams[todrop] <- NULL
    }
    scoreL <- lapply(markergenes, function(gns)
        do.call(normGenesetExpression,
                c(list(sce = sce, genes = gns,
                       expr_values = expr_values,
                       BPPARAM = BPPARAM),
                  normGenesetExpressionParams))
    )
    
    ## identify top scoring cells of each type and create references
    if (length(fraction_topscoring) == 1L)
        fraction_topscoring <- rep(fraction_topscoring, length(markergenes))
    topL <- lapply(seq_along(scoreL), function(i) {
        which(scoreL[[i]] > quantile(scoreL[[i]],
                                     probs = 1 - fraction_topscoring[i]))
    })
    names(topL) <- names(scoreL)
    topcells <- unlist(topL, use.names = FALSE)
    topcelltypes <- factor(rep(names(topL), lengths(topL)),
                           levels = names(markergenes))

    todrop <- intersect(names(aggregateReferenceParams),
                        c("ref", "labels", "BPPARAM"))
    if (length(todrop) > 0) {
        warning("ignoring the following user-provided elements in ",
                "'aggregateReferenceParams': ",
                paste(todrop, collapse = ", "))
        aggregateReferenceParams[todrop] <- NULL
    }
    refs <- do.call(aggregateReference,
                    c(list(ref = sce[, topcells],
                           labels = topcelltypes,
                           BPPARAM = BPPARAM),
                      aggregateReferenceParams))

    # transfer labels using SingleR
    todrop <- intersect(names(SingleRParams),
                        c("test", "ref", "labels", "BPPARAM"))
    if (length(todrop) > 0) {
        warning("ignoring the following user-provided elements in ",
                "'SingleRParams': ",
                paste(todrop, collapse = ", "))
        SingleRParams[todrop] <- NULL
    }
    df <- do.call(SingleR,
                  c(list(test = sce,
                         ref = refs,
                         labels = refs$label,
                         BPPARAM = BPPARAM),
                    SingleRParams))
    
    # return results
    list(cells = topL, refs = refs, labels = df)
}
